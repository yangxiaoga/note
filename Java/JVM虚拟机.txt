		
		
			JVM虚拟机

	1、简介

	最初sun使用的是一款 Classic的Java虚拟机

	到现在引用最广泛的是HotSpot虚拟机，除了sun以外，还有BEA的JRockit
	目前JRockit和HotSpot都被Oracle收入旗下

	2、Java虚拟机的基本结构

	类加载子系统			java栈
	方法区	java堆	直接内存	本地方法栈
	垃圾回收系统			PC寄存器
	执行引擎

	类加载子系统
		从文件系统或者网络中加载Class信息，加载的信息存放在一块称之为
	方法区的内存空间

	方法区
		存放类信息，常量信息，常量池信息，包括字符串字面量和字符串常量

	java堆
		在java虚拟机启动的时候建立java堆，它是java程序最主要的内存工作区域
	几乎所有对象的实例都放到java堆中，堆空间是所有线程共享的

	直接内存
		java的NIO库允许java程序使用直接内存，从而提高性能，通常直接内存速度会
	优于java堆，读写频繁的场合可能会使用

	每个虚拟机线程都有一个私有的栈，一个线程的java栈在线程创建的时候被创建，
	java栈中保存着局部变量，方法参数，同时java的方法调用，返回值

		
	3、Java堆

		java堆可能拥有不同的结构，最为常见的就是将整个java堆
	分为新生代和老年代，其中新生代存放新生的对象或者年龄不大的对象
	老年代则存放老年对象

	新生代分为eden去，s0区，s1区，s0和s1也被称为from和to区域
	他们是两块大小相等，且可以互换角色的空间
	
	绝大多数情况下，对象首先分配在eden区，在一次新生代回收后，如果对象还存活
	则会进入【s0或者s1区】，之后没经过一次新生代回收，如果对象存活则它的年龄就加1
	当对象达到一定年龄后，则进入老年代

	| eden区 | s0区 | s1区 | tenure区(老年代)|
         
	
	为什么s0和s1大小相等？

	复制算法：核心思想内存分为两块，每次只是用一块，垃圾回收时
	正在使用的内存中的存留对象复制到另一块未被使用的内存中去
	之后清除之前正在使用的内存块中的所有的对象，反复交换这两块
	内存的角色，完成垃圾收集

	方法区
		方法区是一块所有线程共享的区域，它保存系统的类信息
		比如类的字段，方法，常量池等，方法区的大小决定了系统
		可以保存多少个类，如果系统定义太多的类，导致方法区溢出
		虚拟机同样会抛出内存溢出错误，方法区可以理解成永久区
	
		
	4、Java栈

		局部变量表
			用于报错函数的参数及局部变量
		操作数栈
			主要保存计算过程的中间结果，同时作为计算过程中变量
			临时地存储空间
		帧数据区
			除了局部变量表和操作数栈以外，栈还需要一些数据来支持常量池的
		解析，这些帧数据区保存中访问常量池的指针，方便程序访问常量池，另外当函数
		返回或者出现异常时，虚拟机必须有一个异常处理表，方便发送异常的时候
		找到异常的代码，因此，异常处理表也是帧数据区的一部分
		
 	5、虚拟机参数

		5.1 堆参数分配
		-XX:+PrintGC 使用这个参数后，虚拟机启动后，只要遇到GC就会打日志
		-XX:+UseSerialGC 配置串行回收器
		-XX:PrintGCDetails 可以查看详细信息，包括整个区的情况
		-Xms: 设置java程序启动时初始堆的大小
		-Xmx: 设置java程序能获得的最大堆的大小
		-Xmx20m -Xms5m -XX:+PrintCommandLineFlags:可以隐式或者显式地将传给虚拟机的参数输出

		在设计工作中，我们可以直接将初始的堆的大小与最大堆的大小设置相等
		这样的好处是可以减少程序运行时的垃圾回收次数，从而提高性能


		-XX 对于系统级别的jvm配置，配置日志信息，或者说配置jvm使用什么垃圾收集器
		非-XX de 基本上都是对应用层面上的配置

		参数值中+表示启用，-表示禁用 
		
		
		-Xmn:可以设置新生代的大小，设置一个比较大的新生代会较少
		老年代的大小，这个参数对系统性能以及GC行为有很大的影响
		新生代大小一般会设置整个堆空间的1/3，到1/4左右

		-XX:SurvivorRatio:用来设置新生代中eden空间和from/to空间的比例，含义
		-XX:SurvivorRatio=eden/from/eden/to


		除了可以设置新生代的绝对大小-Xmn,还可以设置比例
		-XX:NewRatio:设置新生代和老年代的比例
		-XX:NewRatio=老年代/新生代

		
	6、内存溢出
	
	   Out Of Memory
		
		-XX:+HeapDumpOnOutOfMemoryError,使用该参数可以在内存溢出时导出整个堆信息
		-XX:HeapDumpPath,导出堆的存放路径，-XX:HeapDumpPath=路径

		内存分析工具：Memory Analyzer
		jVisual VM
		Jconsole
		
		1M = 1024KB = 1024*1024 byte

		设置线程的最大栈空间，整个参数直接决定了函数可调用的最大深度
		-Xss1m		 	

	7、方法区

		永久区，默认情况下
		-XX:MaxPermSize=64M

		-XX:PermSize=64M JVM初始分配的非堆内存
		-XX:MaxPermSize=128M JVM最大允许分配的非堆内存，按需分配

	8、Client和Server模式
		java虚拟机支持Client和Server两种运行模式，使用参数-client可以
	指定使用Client模式，使用-server可以使用Server模式

	Client模式相对Server启动较快，Server启动较慢，需要对其进行复杂的系统性能
	信息收集和使用复杂算法对程序进行优化，一般生产环境会使用Server模式

	长期运行其性能要远远快于Client模式
	1.7后基本都是Server模式

	
	9、垃圾收集算法

	GC中的垃圾特指存在于内存中，不会再被使用的对象
	而回收就是相当于把垃圾倒掉，他有不同的算法

	如：引用计数法，标记压缩法，复制算法，分代，分区思想

	
	[ 引用计数法 ]
	这是个比较古老而经典的垃圾收集算法，其核心是在对象被其他所引用时
	计数器加1，而当引用失效时，则减1,无法处理循环引用的情况，每次进行加减操作
	比较浪费系统性能

	[ 标记清除法 ]
	分为标记和清除两个阶段，进行处理内存中的对象，弊端是空间碎片问题
	垃圾回收后空间不是连续的，不连续的内存空间的工作效率要低于连续的内存空间

	[ 复制算法 ]
	核心思想是将内存空间划分成两块，每次只是用其中一块，在垃圾回收时
	将正在使用的内存中存留对象复制到未被使用的内存中去，之后去清除之前正在使用
	的内存块中的所有的对象，反复去交换两个内存的角色，完成垃圾收集
	java中新生代from和to空间就是使用这个算法
	
	[ 标记压缩法 ]
	在标记清除法基础之上做了优化，把存活的对象压缩到内存的一端，而后进行
	垃圾清理(Java中老年代使用的就是标记压缩法)

	
	[ 分代算法 ]
	根据对象的特点把内存分成N块，而后根据每个内存的特点使用不同的算法
	对于新生代和老年代来说，新生代回收频率很高，但是很次回收耗时都很短
	而老年代回收频率较低，但是耗时会相对较长，所以应该尽量减少老年代的GC

	[ 分区算法 ]
	将整个内存分为N个小的独立空间，每个空间都可以独立使用，这个细粒度的控制
	一次回收多少个小的空间和哪些小空间，而不是对整个空间进行GC,从而提升性能
	并减少GC的停顿时间

	
	10、对象进入老年代
		
		对象首次创建放置在eden区，如果没有GC介入，对象不会离开eden区，那么
	对象如何进入老年代呢，一般来讲，只要对象的年龄达到一定的大小，就会自动离开
	年轻代，进入老年代，对象年龄是由对象经历数次GC决定的，在新生代每次GC之后如果
	对象没有被回收则年龄加1，虚拟机提供了一个参数来控制新生代对象的最大年龄
	当超过这个年龄范围，就会晋升老年代

	-XX:MaxTenuringThreshold,默认情况下为15

	根据设置XX:MaxTenuringThreshold参数，可以指定新生代对象经过多少次
	回收后就如老年代

	另外，大对象（新生代eden区无法装入时，也会直接进入老年代）
	JVM里有个参数可以设置对象的大小超过指定的大小之后，直接晋升老年代
	-XX:PretenureSizeThredhold	


	使用PretenureSizeThreshold可以指定进入老年代的对象大小
	需要注意TLAB区域有限分配空间

	TLAB - Thread Local Allocation Buffer

	线程本地分配缓冲，从名字看是一个线程专用的内存分配区域
	是为了加速对象分配而生的，每一个线程都会产生一个TLAB
	该线程独享的工作区域，java虚拟机使用这种TLAB区来避免多线程
	冲突问题，提高了对象分配的效率

	TLAB空间一般不会太大，当大对象无法在TLAB分配时，则会直接分配
	到堆上


	-XX:+UseTLAB 使用TLAB
	-XX:TLABSize 设置TLAB大小
	-XX:TLABRefillWasteFraction 设置维护进入TLAB空间的单个对象大小
				    他是一个比例值，默认为64，即如若对象
				    大于整个空间的1/64,则在堆创建对象
	-XX:+PrintTLAB 查看TLAB信息
	-XX:ResizeTLAB 自调整TLABRefillWasteFraction阈值

	
	对象的创建
                                            
                    失败               失败                  失败                  
				               判断是否进入  
	尝试栈上分配 - >  尝试TLAB分配  - >       老年代      - >  eden
			
	
	
	







	
	
	









		
















	
	
	
	