

       排序算法

   	【冒泡排序】
    	冒泡排序是一种简单的排序算法，它重复地走访过要排序的数列，一次比较两个元素，如果他们的
	顺序错误就把他们交换过来。走访数列的工具是重复地进行直到没有再需要交换，也就是说该数列
	已经排序完成，这个算法的名字由来是因为越小的元素会经由交换慢慢浮到数列的顶端

   	 算法描述
   	1、比较相邻的元素，如果第一个比第二个大，叫交换他们两个
    	2、对每一对相邻元素做同样的工作，从开始第一对到结尾的最后一对，这样在最后的元素应该会是最大的数
    	3、针对所有的元素重复以上的步骤，除了最后一个
    	4、重复步骤1-3，直到排序完成

	按照实际情况，比较次数应该是N-1次，但是如果比较N次，最后一个是可以认为是根自己比

        最佳情况：T(n) = O(n)
	最差情况：T(n) = O(n2)
	平均情况：T(n) = O(n2)

	【选择排序】

	选择排序是最稳定的排序算法之一，因为无论什么数据进去都是O（n^2）的时间复杂度
        所以用到它的时候，数据规模越小越好，唯一的好处可能就是不占用额外的内存空间
        理论上讲，选择排序可能也是平时排序一般人能想到的最多的排序方法了吧

        首先在未排序的序列中找到最小(大)元素，存在到排序序列的起始位置，然后，从剩下的未排序元素中
        继续寻找最小(大)元素，然后放到已排序的序列的末尾，以此类推，直到所有元素均排序完毕

        最佳情况：T(n) = O(n2)
	最差情况：T(n) = O(n2)
	平均情况：T(n) = O(n2)
      

       【插入排序】
        简单直观的排序算法，通过构建有序序列，对于未排序数据，从已排序的序列中从后向前扫描
        找到相应位置并插入，插入排序在实现上通常采用in-place排序(即只需用到0（1）的额外空间的排序)、
        因而在从后向前扫描的过程中，需要反复把已排序元素逐步向后挪位，为新元素提供插入空间


        1、从第一个元素开始，钙元素可以认为已经排序
        2、取出下一个元素，在已经排序的元素序列中从后向前扫描
        3、如果该元素（已排序）大于新元素，将该元素移到下一位置
        4、重复步骤3，直到找到已排序的元素小于或者等于新元素的位置
        5、将新元素插入到该位置后
        6、重复步骤2-5

	 算法分析
	最佳情况：T(n) = O(n)
	最坏情况：T(n) = O(n2)
	平均情况：T(n) = O(n2)


	【希尔排序】

         希尔排序是1959年提出的一种排序算法，希尔排序也是一种插入排序
         它是简单插入排序经过改进之后的更搞笑的版本，也称为缩小增量排序
         该算法时冲破o(n^2)的第一批算法之一，他与插入排序的不同之处在于，他会优先
         比较距离较远的元素，希尔排序又叫缩小增量排序
 
         希尔排序是把记录按下表的一定增量分组，对每组使用直接插入排序算法排序，随着增量逐渐减少
         每组包含的关键词越来越多，当增量减至1时，整个文件恰被分成一组，算法便终止


         【步骤】
         我们选择增量gap = length/2,缩小增量继续以gap=gap/2的方式，这种增量选择我们可以用一个序列
         来表示{n/2,(n/2)/2...1},称为增量序列

         希尔排序的增量序列的选择与证明是个数学难题，我们选择的这个增量序列是比较常用的
         也是建议希尔建议的增量，称为希尔增量，但其实这个增量序列不是最优的


         先将整个待排序的记录序列分割成若干子序列分别进行直接插入排序，具体算法描述：

         1、选择一个增量序列t1,t2,...tk,其中ti>tj,tk=1;
         2、按增量序列个数k,对序列进行k趟排序
         3、每趟排序，根据对应的增量ti,将待排序列分隔成若干长度为m的子序列，分别对各子表
            进行直接插入排序，仅增量因子为1时，整个序列作为一个表来处理，表长度即为整个序列的长度



 	* 如：原始数组
 	* 	[ 8 9 1 7 2 3 5 4 6 0] length=10
	 * 初始增量 gap=length/2=5,整个数组被分成5组
 	* 	[8 3] [9 5] [1 4] [7 6] [2 0]
 	* 
 	* 对这5组分别进行直接插入排序，结果如下，可以看到像3,5,6这些小元素都被调到前面了
	 * 	[3 5 1 6 0 8 9 4 7 2 ] 
 	* 
 	* 缩小增量gap=5/2= 2，数组被分成2组
 	*	 [3 1 0 9 7] [5 6 8 4 2]
 	*
 	* 对以上2组分别进行直接插入排序，结果如下:
 	*   [0 2 1 4 3 5 7 6 9 8]
 	*   
 	* 继续缩小增量gap=2/2=1
 	* 变为一组 [0 2 1 4 3 5 7 6 9 8] 
 	* 
 	* 数列已基本有序，再进行一次插入排序
	 * 无需大量的移动操作即可完成整个数组的排序


	算法分析
	最佳情况：T(n) = O(nlog2 n)
	最坏情况：T(n) = O(nlog2 n)
	平均情况：T(n) =O(nlog2n)


	【归并排序】

        和选择排序一样，归并排序的性能不受输入数据的影响，但表现比选择排序好的多
        因为始终都是o(nlogn)的时间复杂度，代价是需要额外的内存空间

        归并排序是建立在归并操作上的一种有效地排序算法，该算法采用分治法的一个非常典型的应用
        归并排序是一种稳定的排序算法，将已有序的子序列合并，得到完全有序的序列
        即先使每个子序列有序，再使子序列段间有序
        若将两个有序表合并成一个有序表，称为2-路归并


       【算法描述】
       步骤1 把长度为n的输入序列分成两个长度为n/2的子序列
       步骤2 对这两个子序列分别采用归并排序
       步骤3 将两个排序好的子序列合并成一个最终的排序序列

       归并排序――将两段排序好的数组结合成一个排序数组

	算法分析
	最佳情况：T(n) = O(n)
	最差情况：T(n) = O(nlogn)
	平均情况：T(n) = O(nlogn)


      【快速排序】

       基本思想：通过一趟排序将待排记录分隔成独立地两部分，其中一部分记录的关键字均比另一部分的关键字小
       则可分别对这两部分记录继续进行排序，以达到整个序列有序

       算法描述
       快速排序使用分治法把一个串list分为两个子串sub-lists,具体算法如下
       步骤1 从数列中挑出一个元素，称为基准
       步骤2 重新排序数列，所有元素比基准值小的摆放在基准前面，所有元素比基准值大的摆在基准的后面
             相同的可以放到任一边，在这个分区退出之后，该基准就处于数列的中间位置
             这个称为分区partition操作

       步骤3 递归地把小于基准元素的子数列和大于基准值元素的子序列排序
 
       
     

       【堆排序】
        利用堆这种数据结构所设计的一种排序算法，堆积是一个近似完全二叉树的结构
        并同时满足堆积的性质：即子节点的键值或索引总是小于或者大于他的父节点

        算法描述
        步骤1 将初始待排序关键字序列(R1,...Rn)构建成大顶堆，此堆为初始的无序区
        步骤2 将堆顶元素R[1] 与最后一个元素R[n]交换，此时得到新的无序区
               R1...Rn-1 和新的有序区 Rn且满足R[1,2...n-1]<= R[n]

        步骤3 由于交换后新的顶堆R[1]可能违法堆的性质，因此需要对当前无序区
              （R1,R2,...Rn-1）调整为新堆，然后再次将R[1]无无序区最后一个元素交换
              得到新的无序区（R1,R2...Rn-2）和新的有序区（Rn-1,Rn）,不断重复此过程直到
              有序区的元素个数为n-1,则整个排序过程完成


        



















 


